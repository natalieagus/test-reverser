module index_reverser#(
    ROW_DIMENSION = 8 : ROW_DIMENSION > 1,
    COLUMN_DIMENSION = 8 : COLUMN_DIMENSION > 1
) (
    input input_address[$clog2(ROW_DIMENSION*COLUMN_DIMENSION)],
    output output_address[$clog2(ROW_DIMENSION*COLUMN_DIMENSION)]
) {
    const ODD_BIT_INDEX = $clog2(COLUMN_DIMENSION)
    const MASK = ODD_BIT_INDEX - 1
    const MSB_INDEX = $clog2(ROW_DIMENSION*COLUMN_DIMENSION) - 1
    
    sig lower_bits_value[ODD_BIT_INDEX]
    
    always {
        lower_bits_value = 0
        // check if we are at odd rows 
        if (input_address[ODD_BIT_INDEX]){
            lower_bits_value = COLUMN_DIMENSION - 1 - input_address[MASK:0]
            output_address = c{input_address[MSB_INDEX:ODD_BIT_INDEX], lower_bits_value}
            //output_address = c{input_address[MSB_INDEX:ODD_BIT_INDEX], input_address[MASK:0] ^ ODD_BIT_INDEXx{b1} }
        }
        else{
            // do not reverse
            output_address = input_address
        }
    }
}